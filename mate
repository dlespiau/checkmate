#!/usr/bin/env python3
# vim: set ts=8 sw=4 et cino=:0,t0,(0,u0,w1,m1:

import bisect
import optparse
import os
import re
import shlex
import signal
import subprocess
import sys

#
# Return back to the directory the script was launched from on SIGINT
#

start_directory = os.getcwd()

def sigint_handler(signal, frame):
    os.chdir(start_directory)
    sys.exit(0)
signal.signal(signal.SIGINT, sigint_handler)

#
# Coloured messages
#

verbose = False
quiet = False
print_colors = { 'debug': 37, 'info': 32, 'warn': 33, 'error': 31 }

def _color_print(level, msg, stream = sys.stdout):
    if os.getenv('ANSI_COLORS_DISABLED') is None:
        color = print_colors[level]
        level = '\033[%dm%s:\033[0m' % (color, level)
    stream.write('%s %s\n' % (level, msg))

def debug(msg):
    _color_print('debug', msg)

def info(msg):
    _color_print('info', msg)

def warn(msg):
    _color_print('warn', msg)

def error(msg):
    _color_print('error', msg)

#
# Helper to execute a command synchronously and get stdout/stderr
#

def execute(cmd):
    args = shlex.split(cmd)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    out, err = p.communicate()
    return out.decode('utf-8').strip(), p.returncode

def execute_to_file(cmd, filename):
    args = shlex.split(cmd)
    f = open(filename, 'w+')
    p = subprocess.Popen(args, stdout=f, stderr=subprocess.STDOUT)
    ret = p.wait()
    f.close()
    return ret

#
# Various helpers
#

def ensure_directories(dirs):
    for d in dirs:
        if not os.path.isdir(d):
            os.mkdir(d)

#
# Exceptions
#

class Error(Exception):
	def __init__(self, msg):
		self.msg = msg

class NotFound(Error):
	pass

class GitError(Error):
	pass

class CollectError(Error):
	pass

class BuildError(Error):
	pass

#
# Represents a git commit
#

class GitCommit:
    def __init__(self, path, rev):
        self.base_path = path
        self.rev = rev
        self._short_hash = None
        self._timestamp = None

        self._hash, ret = execute('git rev-parse %s' % self.rev)
        if ret:
            raise GitError("Failed to parse revision '%s'" % self.rev)

        self._short_hash, ret = execute('git rev-parse --short %s' % self.rev)

        # only store abbrev if it exists and we're not in a detached state
        self._abbrev = None
        abbrev, ret = execute('git rev-parse --abbrev-ref %s' % self.rev)
        if abbrev and abbrev != 'HEAD':
            self._abbrev = abbrev

    def hash(self):
        return self._hash

    def short_hash(self):
        return self._short_hash

    def timestamp(self):
        if self._timestamp:
            return self._timestamp

        self._timestamp, ret = execute('git show -s --format=%%ct %s' %
                                       self._hash)
        if ret:
            raise GitError("Failed to get the commit timestamp of '%s'" %
                           self._hash)

        return self._timestamp

    def checkout(self):
        if self._abbrev:
            execute('git checkout %s' % self._abbrev)
        else:
            execute('git checkout %s' % self.hash())

#
# The on-disk database with all the already treated commits. This is just a
# file with one commit per line, ordered by commit date. Each line is:
#   hash;timestamp
#

class CommitDB:
    def __init__(self, path):
        self.base_path = path
        self.db_path = os.path.join(path, '.mate', 'db')
        ensure_directories(('.mate', ))

    def load(self):
        self.commits = []
        self.keys = []
        if not os.path.exists(self.db_path):
            return

        with open(self.db_path, 'r+') as f:
            for line in f:
                fields = line.split(':')
                fields[-1] = fields[-1].strip()
                self.commits.append(fields)

        # precompute the list of keys for bisect
        self.keys = [c[1] for c in self.commits]

    def save(self):
        with open(self.db_path + '~', 'w+') as f:
            for commit in self.commits:
                f.write("%s:%s\n" % (commit[0], commit[1]))
        os.rename(self.db_path + '~', self.db_path)

    def is_known_commit(self, commit):
        i = bisect.bisect_left(self.keys, commit.timestamp())

        while i < len(self.keys) and self.commits[i][1] == commit.timestamp():
            if self.commits[i][0] == commit.hash():
                return True, i
            i += 1

        return False, -1

    def insert_commit(self, commit):
        i = bisect.bisect_left(self.keys, commit.timestamp())
        self.keys.insert(i, commit.timestamp())
        self.commits.insert(i, (commit.hash(), commit.timestamp()))

#
# An artefact is data collected from a git repository. For instance the output
# (stdout) of a build is the artefact used by the CompilationWarningMetric
#

class Artefact:
    def __init__(self, project, args=None):
        self.project = project
        self.commit = project.current_commit
        self.artefact_dir = project.hash_dirs['artefacts']
        self.args = args

    def _info(self, msg):
        info('%s: %s' % (self.commit.short_hash(), msg))

    def _artefact(self, name, command):
        self._info("Generating artefact '%s'" % name)
        f = os.path.join(self.artefact_dir, name)
        return execute_to_file(command, f)

    def ensure_collect(self):
        pass

    def collect(self):
        self.ensure_collect()
        self.do_collect()

class BuildArtefact(Artefact):
    name = 'build'

    def ensure_collect(self):
        if not os.path.isfile('Makefile'):
            raise CollectError("%s has no Makefile" % self.project.path)

    def do_collect(self):
        self._artefact('clean', 'make clean')
        self._artefact('build', 'make')
#
# A metric is an object that collect data on an artefact
#

class Metric:
    def __init__(self, project, args=None):
        self.project = project
        self.commit = project.current_commit
        self.artefact_file = os.path.join(project.hash_dirs['artefacts'],
                                          self.__class__.artefact)
        self.args = args

        self.value = 0

    def _info(self, msg):
        info('%s: %s' % (self.commit.short_hash(), msg))

    def analyse(self):
        self.do_analyse()

class CompilationWarningMetric(Metric):
    artefact = 'build'
    name = 'compilation-warnings'

    def do_analyse(self):
        r = re.compile(':[0-9]+:[0-9]+: warning:')
        with open(self.artefact_file, 'r') as f:
            for line in f:
                if r.search(line):
                    self.value += 1

#
# Represents the software project we want to gather metrics on
#

class Project:
    def __init__(self, path):
        self.path = path
        self.db = CommitDB(path)
        self.db.load()
        self.hash_dirs = {}

    def setup_hash_dir(self, name):
        git_sha = self.current_commit.hash()
        hash_dir = os.path.join('.mate', name)
        short_dir = os.path.join(hash_dir, git_sha[:2])
        long_dir = os.path.join(short_dir, git_sha[2:])
        self.hash_dirs[name] = long_dir
        ensure_directories((hash_dir, short_dir, long_dir))

    def setup(self, rev='HEAD'):
        try:
            os.chdir(self.path)
        except FileNotFoundError:
            raise NotFound("%s not a directory" % self.path)

        if not os.path.isdir('.git'):
            raise GitError("%s is not a git repository" % self.path)

        self.start_commit = GitCommit(self.path, 'HEAD')
        self.current_commit = GitCommit(self.path, rev)

        ensure_directories(('.mate', ))
        self.setup_hash_dir('artefacts')
        self.setup_hash_dir('metrics')

        # checkout the commit we want to inspect
        self.current_commit.checkout()

    def fini(self):
        global start_directory

        self.start_commit.checkout()
        os.chdir(start_directory)

    def _debug(self, msg):
        debug('%s: %s' % (self.current_commit.short_hash(), msg))

    def _info(self, msg):
        info('%s: %s' % (self.current_commit.short_hash(), msg))

    def _done(self):
        self.db.insert_commit(self.current_commit)
        self.db.save()

    def collect_artefacts(self):
        known, index = self.db.is_known_commit(self.current_commit)
        if known:
            self._debug('Artefacts already generated')
            return

        build = BuildArtefact(self)
        build.collect()

        self._done()

    def collect_metrics(self):
        warnings = CompilationWarningMetric(self)
        warnings.analyse()
        self._info('%d warnings' % warnings.value)

usage = """Usage: mate [options] command"

List of commands:
    help                        display this help
    analyse [commit]            analyse commit (default to HEAD)"""

parser = optparse.OptionParser(usage, version=1.0)

def parse_options(args):
    global parser

    parser.add_option("-v", "--verbose", action="store_true",
            dest="verbose", default=False,
            help="be more verbose")

    parser.add_option("-C", "", action="store_true", dest="directory",
            default='.', help="change to directory")

    (options, args) = parser.parse_args()

    return (options, args)

def usage():
    parser.print_help()
    sys.exit(1)

class Mate:
    def __init__(self):
        self.commands = ('help', 'analyse', )

    def is_known_command(self, cmd):
        return cmd in self.commands

    def help(self, args):
        usage()

    def analyse(self, args):
        rev = 'HEAD'
        if len(args) > 0:
            rev = args[0]

        project = Project(options.directory)

        try:
            project.setup(rev)
            project.collect_artefacts()
            project.collect_metrics()
        except Error as e:
            print("Error: %s" % e.msg)
            sys.exit(1)
        finally:
            project.fini()

    def dispatch(self, cmd, args):
        if not mate.is_known_command(cmd):
            error("Unknown command '%s'" % cmd)
            sys.exit(1)

        method = getattr(self, cmd)
        method(args)


if __name__ == '__main__':
    (options, args) = parse_options(sys.argv[1:])
    verbose = options.verbose

    if len(args) == 0:
        usage()

    mate = Mate()
    mate.dispatch(args[0], args[1:])
